# Topic: Parser & Building an Abstract Syntax Tree

**Course** : Formal Languages & Finite Automata

**Author** : Baxanean Constantin

***

## Theory

 Parsers are essential components in programming language processing. They analyze the structure of a sequence of tokens, typically generated by a lexer, and ensure it adheres to the syntax rules defined by a language or grammar. Parsers construct parse trees or abstract syntax trees (ASTs) that represent the hierarchical structure of code. They play a crucial role in interpreting, compiling, analyzing, and enhancing code editors. Parsers use formal grammar specifications to define syntax rules and perform error detection and recovery. Overall, parsers are fundamental tools for language processing, enabling efficient code understanding and processing.
***

## Objectives
- Get familiar with parsing, what it is and how it can be programmed
- Get familiar with the concept of AST

***

## Implementation description

So, the first step to implement the Parser is to create the parser tree, that will define our blocks and how the expression will be split up. Here is the code for the parser tree: 

```
class ParseTree:
    def __init__(self, n_type, value=None, children=None):
        self.type = n_type
        self.value = value
        self.children = children or []

    def __str__(self, level=0):
        if self.value is None:
            ret = "\t" * level + self.type + "\n"
        else:
            ret = "\t" * level + self.type + ": " + str(self.value) + "\n"
        for child in self.children:
            ret += child.__str__(level + 1)
        return ret
```

Next, we create the parser itself. It contains functions, some of them that will iterate the whole program, and some of them that split up the expression given. The first function is used to find the integers that I have: 
```
def parse_factor(self, parent_node):
        parse_node = ParseTree("SECTION")
        parent_node.children.append(parse_node)
        if self.tokens[self.index][0] == "LPAREN":
            parse_node.children.append(ParseTree(self.tokens[self.index][0], self.tokens[self.index][1]))
            self.index += 1
            self.parse_expression(parse_node)
            if self.tokens[self.index][0] == "RPAREN":
                parse_node.children.append(ParseTree(self.tokens[self.index][0], self.tokens[self.index][1]))
                self.index += 1
        elif self.tokens[self.index][0] in ["INT"]:
            parse_node.children.append(ParseTree(self.tokens[self.index][0], self.tokens[self.index][1]))
            self.index += 1
```
The purpose of it is to start the parsing. The next function has the purpose to name all the plus and minus signs in my expression. 
```
def parse_add(self, parent_node):
        parse_node = ParseTree("EXPRESSION")
        parent_node.children.append(parse_node)
        self.parse_multiply(parse_node)
        if self.tokens[self.index][0] in ["PLUS", "MINUS"]:
            parse_node.children.append(ParseTree(self.tokens[self.index][0], self.tokens[self.index][1]))
            self.index += 1
            self.parse_term(parse_node)
```
And last, but not least, the function that names the multiply and divide signs inside the expression: 
```
def parse_multiply(self, parent_node):
        parse_node = ParseTree("TERM")
        parent_node.children.append(parse_node)
        self.parse_factor(parse_node)
        if self.tokens[self.index][0] in ["MULTIPLY", "DIVIDE"]:
            parse_node.children.append(ParseTree(self.tokens[self.index][0], self.tokens[self.index][1]))
            self.index += 1
            self.parse_factor(parse_node)
```

Also, I changed the main from laboratory work 3. now it implements the parsing function.
## Results
The expression has been split up into blocks. The parsing tree helped me implement parent nodes and child nodes. Even though the output looks chaotic, it is clealry shown what everything does there:
```
PROGRAM
        EXPRESSION
                TERM
                        SECTION
                                INT: 22
                PLUS: +
                TERM
                        SECTION
                                INT: 12
                        MULTIPLY: *
                        SECTION
                                LPAREN: (
                                EXPRESSION
                                        TERM
                                                SECTION
                                                        INT: 14
                                        MINUS: -
                                        TERM
                                                SECTION
                                                        INT: 1
                                                DIVIDE: /
                                                SECTION
                                                        INT: 6
                                RPAREN: )
```

## Conclusion

In conclusion, parsers play a crucial role in computer science and programming languages. Here are the key reasons why parsers are important:

1. Syntax Analysis: Parsers perform syntax analysis by analyzing the structure of input strings according to a formal grammar. They ensure that the input conforms to the grammar rules and can identify syntactic errors. This process is vital for compilers, interpreters, and other language processing tools to correctly understand and process code.

2. Language Processing: Parsers are fundamental components in language processing tasks such as compiling, interpreting, and transpiling programming languages. They help transform human-readable code into a format that can be executed by machines or further processed.

3. Error Detection and Reporting: Parsers are responsible for identifying and reporting syntax errors in the input. By detecting errors early, parsers help programmers catch and fix mistakes, improving code quality and reducing debugging time. Meaningful error messages generated by parsers facilitate the development process by pinpointing the exact location and nature of errors.

4. Code Transformation and Analysis: Parsers generate structured representations of code, such as abstract syntax trees (ASTs), which capture the essential structure and semantics of programs. ASTs enable further analysis and transformations, such as optimization, refactoring, code generation, and static analysis. These tasks are essential for improving program performance, maintainability, and identifying potential bugs or security vulnerabilities.

5. Language Design and Development: Parsers are vital for designing new programming languages or extending existing ones. They help define the syntax and grammar rules of a language, which form the basis for writing code. Parsers allow language designers to express their language's constructs, constraints, and semantics, enabling programmers to create expressive and powerful applications.

Overall, parsers are fundamental tools in language processing, error detection, code analysis, and code transformation. They enable efficient and accurate interpretation or compilation of programming languages, leading to improved development processes, code quality, and the creation of innovative programming languages and applications.

## References
1. https://www.techtarget.com/searchapparchitecture/definition/parser#:~:text=A%20parser%20is%20a%20program%20that%20is%20part%20of%20the,other%20software%20can%20understand%20it.
2. https://www.javatpoint.com/parser
